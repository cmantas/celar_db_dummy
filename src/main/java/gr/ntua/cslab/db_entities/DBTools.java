/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package gr.ntua.cslab.db_entities;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;
import java.util.Map;

/**
 *Helper class with static methods that abstract DataBase operations
 * @author cmantas
 */
public class DBTools extends DBConnectable{
    
    /**
     * The static initializer creates the connection to the DB
     */
    static{
        openConnection();
    }        
        
    
    static ResultSet execute_all(String query, boolean isUpdate) throws DBException {
         ResultSet rv = null;
        try {
            LOG.debug(query);
            Statement statement;
            statement = connection.createStatement();
            if (isUpdate){
                statement.executeUpdate(query);
                statement.close();
            }
            else{
                rv= statement.executeQuery(query);
            }
        } catch (SQLException ex) {
            ex.printStackTrace();
            throw new DBException(ex, query);
        }
            return rv;
    }
     
    
   static ResultSet executeQuery(String query) throws DBException{
       return execute_all(query, false);
   }
   
   static void executeUpdate(String query) throws DBException{
       execute_all(query, true);
   }
        
    /**
     * Method used to insert previously formatted data to the database. The data
     * (modeled as a Map) must already be formatted in a manner of
     * Field_Name->Value
     *
     * @param tableName
     * @param data a map of fields->values for this particular table
     * @throws gr.ntua.cslab.db_entities.DBException in case of an error in the insertion
     *
     */
    public static void insertData(String tableName, Map<String, String> data) throws DBException {
        String query = SQLTools.insertSQL(tableName, data);
        executeUpdate(query);
    }

    /**
     * Inserts a tuple in a table and retrieves the 'id' field when it is stored
     * Assumes that the table has a auto-increment/serial field named 'id'
     * @param tableName
     * @param data
     * @return
     * @throws DBException 
     */
    public static int insertIDData(String tableName, Map<String, String> data) throws DBException {
        data.put("id", "DEFAULT");
            
        String query = SQLTools.insertSQL(tableName, data);
        LOG.debug(query);
        try {
            Statement statement = connection.createStatement();
            statement.execute(query, Statement.RETURN_GENERATED_KEYS);
            ResultSet tableKeys = statement.getGeneratedKeys();
            tableKeys.next();
            int autoGeneratedID = tableKeys.getInt("id");
            statement.close();
            return autoGeneratedID;
        } catch (SQLException e) {
            throw new DBException(e, query);
        }
    }
        
        
    /**
     * Returns the max value of a specified field, null if table is empty
     *
     * @param field
     * @return
     */
    static String maxValue(String tableName, String field){
        Statement statement;
        String query = "SELECT MAX(" + field + ") FROM \"" + tableName + "\";";
        LOG.debug(query);
        try {
            ResultSet set = executeQuery(query);
            set.next();
            String result = set.getString("max");
            set.close();
            return result;
        } catch (SQLException ex) {
            System.out.println(ex);
            ex.printStackTrace();
            return null;
        }

    }
    
    /**
     * Deletes a row from a table based on all its fields.
     *
     * @param tableName
     * @param fields
     * @throws gr.ntua.cslab.db_entities.DBException
     */
    public static void doDelete(String tableName, Map<String, String> fields) throws DBException {
        String sql = SQLTools.deleteSQL(tableName, fields);
        executeUpdate(sql);
    }

    /**
     * Deletes a row from a table based on (only) the id field.
     *
     * @param tableName
     * @param id
     * @throws gr.ntua.cslab.db_entities.DBException
     */
    public static void doDeleteID(String tableName, int id) throws DBException {
        String sql = SQLTools.deleteSQL(tableName, "id", "'" + id + "'");
        executeUpdate(sql);
    }

    /**
     * Retrieves from the table a Mapping of fields-->values for each of the
     * table tuples that satisfy the whereStatement
     *
     * @param tableName
     * @param whereStatement an SQL condition to be added after "WHERE" clause
     * command
     * @return a List of mappings of ColumnNames--> Values
     * @throws gr.ntua.cslab.db_entities.DBException in case of an error in the query
     */
    public static List<Map<String, String>> doSelect(String tableName, String whereStatement) throws DBException {
        String query = SQLTools.selectSQL(tableName, whereStatement);
        //try executing the query, else return null
        List<Map<String, String>> results = new java.util.LinkedList();
        ResultSet resultSet = executeQuery(query);
        try {
            ResultSetMetaData rsmd = resultSet.getMetaData();
            //create the map of ColumnNames->List_of_Values
            int columnCount = rsmd.getColumnCount();
            //iterate through results and fill the maps
            while (resultSet.next()) {
                Map<String, String> map = new java.util.TreeMap();
                for (int i = 1; i <= columnCount; i++) {
                    String columnName = rsmd.getColumnLabel(i);
                    //select the correct list from the mapp and add the value
                    map.put(columnName, resultSet.getString(i));
                }
                results.add(map);
            }
            resultSet.close();
        } catch (SQLException e) {
            throw new DBException(e, query);
        }
        return results;
    }
    
    /**
     * Selects from the table all tuples where the a given field matches a given value;
     * @param tablename
     * @param field the Column name of to be used in the "WHERE" statement
     * @param value the desired value
     * @return a List of mappings of ColumnNames--> Values
     * @throws DBException in case of an  error in the query
     */
    public static List<Map<String, String>> doSelectByField(String tablename, String field, String value) throws DBException {
        return doSelect(tablename, "\""+field + "\" ='" + value + "'");
    }

    /**
     * Retrieves the line that has the specified 'id' (assumed unique)
     *
     * @param tableName
     * @param id
     * @return a Map of ColumnName->Value for this entry
     */
    public static Map<String, String> doSelectByID(String tableName, int id) {
        String query = SQLTools.selectSQL(tableName, "id=" + id);
        LOG.debug(query);
        try {
            Map<String, String> result = new java.util.TreeMap();
            Statement statement = connection.createStatement();
            ResultSet rs = statement.executeQuery(query);
            ResultSetMetaData rsmd = rs.getMetaData();
            int columnCount = rsmd.getColumnCount();
            rs.next();
            for (int i = 1; i < columnCount + 1; i++) {
                String name = rsmd.getColumnName(i);
                String value = SQLTools.decode(rs.getString(name));
                result.put(name, value);
            }
            return result;
        } catch (SQLException ex) {
            System.err.println("Query failed: \n" + query);
            ex.printStackTrace();
        }
        return null;
    }
}
